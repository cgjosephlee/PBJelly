

Map the reads to the reference

blasr filtered_subreads.fastq lambda_modified.fasta -bestn 1 -nCandidates 15 -sdpTupleSize 6 \
      -minPctIdentity 75 -affineAlign -noSplitSubreads -nproc 1 -sam -clipping soft -out mapping.sam

Turn the .sam output into a .bam

sam2bam lambda_modified.fasta mapping.sam

This creates mapping.bam

Extract and map the tails
Honey.py pie mapping.bam lambda_modified.fasta

Sort the bam
samtools sort mapping.bam mappingSort

Call MD (for spot calling later - this is optional if you only want tails)
samtools calmd -b lambda_modified.fasta mappingSort.bam > mappingFinal.bam

Polish off the bam
samtools index mappingFinal.bam

Call Tails and Spots (can be done concurrently)
Honey.py tails mappingFinal.bam
Honey.py spots mappingFinal.bam

Finished!


#what exact variants should we find?
#Be sure to point out the double circular reference (apparently half of the
#lambdas don't have the beginning 800bp in the reference for whatever reason!

#Have them rerun it with -v and with -B 1000
#Describe why the input is different!
#Then be like, be we expect at this coverage (calculate lambda coverage) that
we'd want to see about (1/10th) of the reads to have the break, so let's
increase the min numReads to 10
#it seems like on random in a 1kb window you're going to get about 4 missed
#adapter reads given X coverage
#reads with missed adapters
